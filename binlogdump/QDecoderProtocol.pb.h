// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: QDecoderProtocol.proto

#ifndef PROTOBUF_INCLUDED_QDecoderProtocol_2eproto
#define PROTOBUF_INCLUDED_QDecoderProtocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_QDecoderProtocol_2eproto 

namespace protobuf_QDecoderProtocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_QDecoderProtocol_2eproto
namespace com {
namespace woqutech {
namespace qdecoder {
namespace packages {
class Ack;
class AckDefaultTypeInternal;
extern AckDefaultTypeInternal _Ack_default_instance_;
class ClientAck;
class ClientAckDefaultTypeInternal;
extern ClientAckDefaultTypeInternal _ClientAck_default_instance_;
class ClientAuth;
class ClientAuthDefaultTypeInternal;
extern ClientAuthDefaultTypeInternal _ClientAuth_default_instance_;
class ClientRollback;
class ClientRollbackDefaultTypeInternal;
extern ClientRollbackDefaultTypeInternal _ClientRollback_default_instance_;
class Dump;
class DumpDefaultTypeInternal;
extern DumpDefaultTypeInternal _Dump_default_instance_;
class Get;
class GetDefaultTypeInternal;
extern GetDefaultTypeInternal _Get_default_instance_;
class Handshake;
class HandshakeDefaultTypeInternal;
extern HandshakeDefaultTypeInternal _Handshake_default_instance_;
class HeartBeat;
class HeartBeatDefaultTypeInternal;
extern HeartBeatDefaultTypeInternal _HeartBeat_default_instance_;
class Messages;
class MessagesDefaultTypeInternal;
extern MessagesDefaultTypeInternal _Messages_default_instance_;
class Packet;
class PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class Sub;
class SubDefaultTypeInternal;
extern SubDefaultTypeInternal _Sub_default_instance_;
class Unsub;
class UnsubDefaultTypeInternal;
extern UnsubDefaultTypeInternal _Unsub_default_instance_;
}  // namespace packages
}  // namespace qdecoder
}  // namespace woqutech
}  // namespace com
namespace google {
namespace protobuf {
template<> ::com::woqutech::qdecoder::packages::Ack* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::Ack>(Arena*);
template<> ::com::woqutech::qdecoder::packages::ClientAck* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::ClientAck>(Arena*);
template<> ::com::woqutech::qdecoder::packages::ClientAuth* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::ClientAuth>(Arena*);
template<> ::com::woqutech::qdecoder::packages::ClientRollback* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::ClientRollback>(Arena*);
template<> ::com::woqutech::qdecoder::packages::Dump* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::Dump>(Arena*);
template<> ::com::woqutech::qdecoder::packages::Get* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::Get>(Arena*);
template<> ::com::woqutech::qdecoder::packages::Handshake* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::Handshake>(Arena*);
template<> ::com::woqutech::qdecoder::packages::HeartBeat* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::HeartBeat>(Arena*);
template<> ::com::woqutech::qdecoder::packages::Messages* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::Messages>(Arena*);
template<> ::com::woqutech::qdecoder::packages::Packet* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::Packet>(Arena*);
template<> ::com::woqutech::qdecoder::packages::Sub* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::Sub>(Arena*);
template<> ::com::woqutech::qdecoder::packages::Unsub* Arena::CreateMaybeMessage<::com::woqutech::qdecoder::packages::Unsub>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace com {
namespace woqutech {
namespace qdecoder {
namespace packages {

enum Compression {
  COMPRESSIONCOMPATIBLEPROTO2 = 0,
  NONE = 1,
  ZLIB = 2,
  GZIP = 3,
  LZF = 4,
  Compression_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Compression_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Compression_IsValid(int value);
const Compression Compression_MIN = COMPRESSIONCOMPATIBLEPROTO2;
const Compression Compression_MAX = LZF;
const int Compression_ARRAYSIZE = Compression_MAX + 1;

const ::google::protobuf::EnumDescriptor* Compression_descriptor();
inline const ::std::string& Compression_Name(Compression value) {
  return ::google::protobuf::internal::NameOfEnum(
    Compression_descriptor(), value);
}
inline bool Compression_Parse(
    const ::std::string& name, Compression* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Compression>(
    Compression_descriptor(), name, value);
}
enum PacketType {
  PACKAGETYPECOMPATIBLEPROTO2 = 0,
  HANDSHAKE = 1,
  CLIENTAUTHENTICATION = 2,
  ACK = 3,
  SUBSCRIPTION = 4,
  UNSUBSCRIPTION = 5,
  GET = 6,
  MESSAGES = 7,
  CLIENTACK = 8,
  SHUTDOWN = 9,
  DUMP = 10,
  HEARTBEAT = 11,
  CLIENTROLLBACK = 12,
  PacketType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PacketType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PacketType_IsValid(int value);
const PacketType PacketType_MIN = PACKAGETYPECOMPATIBLEPROTO2;
const PacketType PacketType_MAX = CLIENTROLLBACK;
const int PacketType_ARRAYSIZE = PacketType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PacketType_descriptor();
inline const ::std::string& PacketType_Name(PacketType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PacketType_descriptor(), value);
}
inline bool PacketType_Parse(
    const ::std::string& name, PacketType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketType>(
    PacketType_descriptor(), name, value);
}
// ===================================================================

class Packet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.Packet) */ {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Packet(Packet&& from) noexcept
    : Packet() {
    *this = ::std::move(from);
  }

  inline Packet& operator=(Packet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet& default_instance();

  enum MagicNumberPresentCase {
    kMagicNumber = 1,
    MAGIC_NUMBER_PRESENT_NOT_SET = 0,
  };

  enum VersionPresentCase {
    kVersion = 2,
    VERSION_PRESENT_NOT_SET = 0,
  };

  enum CompressionPresentCase {
    kCompression = 4,
    COMPRESSION_PRESENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
               &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Packet* other);
  friend void swap(Packet& a, Packet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Packet* New() const final {
    return CreateMaybeMessage<Packet>(NULL);
  }

  Packet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Packet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Packet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes body = 5;
  void clear_body();
  static const int kBodyFieldNumber = 5;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // .com.woqutech.qdecoder.packages.PacketType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::com::woqutech::qdecoder::packages::PacketType type() const;
  void set_type(::com::woqutech::qdecoder::packages::PacketType value);

  // int32 magic_number = 1;
  private:
  bool has_magic_number() const;
  public:
  void clear_magic_number();
  static const int kMagicNumberFieldNumber = 1;
  ::google::protobuf::int32 magic_number() const;
  void set_magic_number(::google::protobuf::int32 value);

  // int32 version = 2;
  private:
  bool has_version() const;
  public:
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // .com.woqutech.qdecoder.packages.Compression compression = 4;
  private:
  bool has_compression() const;
  public:
  void clear_compression();
  static const int kCompressionFieldNumber = 4;
  ::com::woqutech::qdecoder::packages::Compression compression() const;
  void set_compression(::com::woqutech::qdecoder::packages::Compression value);

  void clear_magic_number_present();
  MagicNumberPresentCase magic_number_present_case() const;
  void clear_version_present();
  VersionPresentCase version_present_case() const;
  void clear_compression_present();
  CompressionPresentCase compression_present_case() const;
  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.Packet)
 private:
  void set_has_magic_number();
  void set_has_version();
  void set_has_compression();

  inline bool has_magic_number_present() const;
  inline void clear_has_magic_number_present();

  inline bool has_version_present() const;
  inline void clear_has_version_present();

  inline bool has_compression_present() const;
  inline void clear_has_compression_present();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  int type_;
  union MagicNumberPresentUnion {
    MagicNumberPresentUnion() {}
    ::google::protobuf::int32 magic_number_;
  } magic_number_present_;
  union VersionPresentUnion {
    VersionPresentUnion() {}
    ::google::protobuf::int32 version_;
  } version_present_;
  union CompressionPresentUnion {
    CompressionPresentUnion() {}
    int compression_;
  } compression_present_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[3];

  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartBeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.HeartBeat) */ {
 public:
  HeartBeat();
  virtual ~HeartBeat();

  HeartBeat(const HeartBeat& from);

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartBeat(HeartBeat&& from) noexcept
    : HeartBeat() {
    *this = ::std::move(from);
  }

  inline HeartBeat& operator=(HeartBeat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartBeat* internal_default_instance() {
    return reinterpret_cast<const HeartBeat*>(
               &_HeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(HeartBeat* other);
  friend void swap(HeartBeat& a, HeartBeat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartBeat* New() const final {
    return CreateMaybeMessage<HeartBeat>(NULL);
  }

  HeartBeat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartBeat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 send_timestamp = 1;
  void clear_send_timestamp();
  static const int kSendTimestampFieldNumber = 1;
  ::google::protobuf::int64 send_timestamp() const;
  void set_send_timestamp(::google::protobuf::int64 value);

  // int64 start_timestamp = 2;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 2;
  ::google::protobuf::int64 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.HeartBeat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 send_timestamp_;
  ::google::protobuf::int64 start_timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Handshake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.Handshake) */ {
 public:
  Handshake();
  virtual ~Handshake();

  Handshake(const Handshake& from);

  inline Handshake& operator=(const Handshake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Handshake(Handshake&& from) noexcept
    : Handshake() {
    *this = ::std::move(from);
  }

  inline Handshake& operator=(Handshake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Handshake& default_instance();

  enum CommunicationEncodingPresentCase {
    kCommunicationEncoding = 1,
    COMMUNICATION_ENCODING_PRESENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Handshake* internal_default_instance() {
    return reinterpret_cast<const Handshake*>(
               &_Handshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Handshake* other);
  friend void swap(Handshake& a, Handshake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Handshake* New() const final {
    return CreateMaybeMessage<Handshake>(NULL);
  }

  Handshake* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Handshake>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Handshake& from);
  void MergeFrom(const Handshake& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Handshake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes seeds = 2;
  void clear_seeds();
  static const int kSeedsFieldNumber = 2;
  const ::std::string& seeds() const;
  void set_seeds(const ::std::string& value);
  #if LANG_CXX11
  void set_seeds(::std::string&& value);
  #endif
  void set_seeds(const char* value);
  void set_seeds(const void* value, size_t size);
  ::std::string* mutable_seeds();
  ::std::string* release_seeds();
  void set_allocated_seeds(::std::string* seeds);

  // .com.woqutech.qdecoder.packages.Compression supported_compressions = 3;
  void clear_supported_compressions();
  static const int kSupportedCompressionsFieldNumber = 3;
  ::com::woqutech::qdecoder::packages::Compression supported_compressions() const;
  void set_supported_compressions(::com::woqutech::qdecoder::packages::Compression value);

  // string communication_encoding = 1;
  private:
  bool has_communication_encoding() const;
  public:
  void clear_communication_encoding();
  static const int kCommunicationEncodingFieldNumber = 1;
  const ::std::string& communication_encoding() const;
  void set_communication_encoding(const ::std::string& value);
  #if LANG_CXX11
  void set_communication_encoding(::std::string&& value);
  #endif
  void set_communication_encoding(const char* value);
  void set_communication_encoding(const char* value, size_t size);
  ::std::string* mutable_communication_encoding();
  ::std::string* release_communication_encoding();
  void set_allocated_communication_encoding(::std::string* communication_encoding);

  void clear_communication_encoding_present();
  CommunicationEncodingPresentCase communication_encoding_present_case() const;
  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.Handshake)
 private:
  void set_has_communication_encoding();

  inline bool has_communication_encoding_present() const;
  inline void clear_has_communication_encoding_present();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr seeds_;
  int supported_compressions_;
  union CommunicationEncodingPresentUnion {
    CommunicationEncodingPresentUnion() {}
    ::google::protobuf::internal::ArenaStringPtr communication_encoding_;
  } communication_encoding_present_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientAuth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.ClientAuth) */ {
 public:
  ClientAuth();
  virtual ~ClientAuth();

  ClientAuth(const ClientAuth& from);

  inline ClientAuth& operator=(const ClientAuth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientAuth(ClientAuth&& from) noexcept
    : ClientAuth() {
    *this = ::std::move(from);
  }

  inline ClientAuth& operator=(ClientAuth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientAuth& default_instance();

  enum NetReadTimeoutPresentCase {
    kNetReadTimeout = 3,
    NET_READ_TIMEOUT_PRESENT_NOT_SET = 0,
  };

  enum NetWriteTimeoutPresentCase {
    kNetWriteTimeout = 4,
    NET_WRITE_TIMEOUT_PRESENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientAuth* internal_default_instance() {
    return reinterpret_cast<const ClientAuth*>(
               &_ClientAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ClientAuth* other);
  friend void swap(ClientAuth& a, ClientAuth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientAuth* New() const final {
    return CreateMaybeMessage<ClientAuth>(NULL);
  }

  ClientAuth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientAuth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientAuth& from);
  void MergeFrom(const ClientAuth& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientAuth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // bytes password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const void* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string destination = 5;
  void clear_destination();
  static const int kDestinationFieldNumber = 5;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // string client_id = 6;
  void clear_client_id();
  static const int kClientIdFieldNumber = 6;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // string filter = 7;
  void clear_filter();
  static const int kFilterFieldNumber = 7;
  const ::std::string& filter() const;
  void set_filter(const ::std::string& value);
  #if LANG_CXX11
  void set_filter(::std::string&& value);
  #endif
  void set_filter(const char* value);
  void set_filter(const char* value, size_t size);
  ::std::string* mutable_filter();
  ::std::string* release_filter();
  void set_allocated_filter(::std::string* filter);

  // int64 start_timestamp = 8;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 8;
  ::google::protobuf::int64 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::int64 value);

  // int32 net_read_timeout = 3;
  private:
  bool has_net_read_timeout() const;
  public:
  void clear_net_read_timeout();
  static const int kNetReadTimeoutFieldNumber = 3;
  ::google::protobuf::int32 net_read_timeout() const;
  void set_net_read_timeout(::google::protobuf::int32 value);

  // int32 net_write_timeout = 4;
  private:
  bool has_net_write_timeout() const;
  public:
  void clear_net_write_timeout();
  static const int kNetWriteTimeoutFieldNumber = 4;
  ::google::protobuf::int32 net_write_timeout() const;
  void set_net_write_timeout(::google::protobuf::int32 value);

  void clear_net_read_timeout_present();
  NetReadTimeoutPresentCase net_read_timeout_present_case() const;
  void clear_net_write_timeout_present();
  NetWriteTimeoutPresentCase net_write_timeout_present_case() const;
  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.ClientAuth)
 private:
  void set_has_net_read_timeout();
  void set_has_net_write_timeout();

  inline bool has_net_read_timeout_present() const;
  inline void clear_has_net_read_timeout_present();

  inline bool has_net_write_timeout_present() const;
  inline void clear_has_net_write_timeout_present();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::internal::ArenaStringPtr filter_;
  ::google::protobuf::int64 start_timestamp_;
  union NetReadTimeoutPresentUnion {
    NetReadTimeoutPresentUnion() {}
    ::google::protobuf::int32 net_read_timeout_;
  } net_read_timeout_present_;
  union NetWriteTimeoutPresentUnion {
    NetWriteTimeoutPresentUnion() {}
    ::google::protobuf::int32 net_write_timeout_;
  } net_write_timeout_present_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.Ack) */ {
 public:
  Ack();
  virtual ~Ack();

  Ack(const Ack& from);

  inline Ack& operator=(const Ack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ack(Ack&& from) noexcept
    : Ack() {
    *this = ::std::move(from);
  }

  inline Ack& operator=(Ack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ack& default_instance();

  enum ErrorCodePresentCase {
    kErrorCode = 1,
    ERROR_CODE_PRESENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ack* internal_default_instance() {
    return reinterpret_cast<const Ack*>(
               &_Ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Ack* other);
  friend void swap(Ack& a, Ack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ack* New() const final {
    return CreateMaybeMessage<Ack>(NULL);
  }

  Ack* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ack>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ack& from);
  void MergeFrom(const Ack& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_message = 2;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // int32 error_code = 1;
  private:
  bool has_error_code() const;
  public:
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  void clear_error_code_present();
  ErrorCodePresentCase error_code_present_case() const;
  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.Ack)
 private:
  void set_has_error_code();

  inline bool has_error_code_present() const;
  inline void clear_has_error_code_present();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  union ErrorCodePresentUnion {
    ErrorCodePresentUnion() {}
    ::google::protobuf::int32 error_code_;
  } error_code_present_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.ClientAck) */ {
 public:
  ClientAck();
  virtual ~ClientAck();

  ClientAck(const ClientAck& from);

  inline ClientAck& operator=(const ClientAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientAck(ClientAck&& from) noexcept
    : ClientAck() {
    *this = ::std::move(from);
  }

  inline ClientAck& operator=(ClientAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientAck* internal_default_instance() {
    return reinterpret_cast<const ClientAck*>(
               &_ClientAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ClientAck* other);
  friend void swap(ClientAck& a, ClientAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientAck* New() const final {
    return CreateMaybeMessage<ClientAck>(NULL);
  }

  ClientAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientAck& from);
  void MergeFrom(const ClientAck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destination = 1;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // int64 batch_id = 3;
  void clear_batch_id();
  static const int kBatchIdFieldNumber = 3;
  ::google::protobuf::int64 batch_id() const;
  void set_batch_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.ClientAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::int64 batch_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sub : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.Sub) */ {
 public:
  Sub();
  virtual ~Sub();

  Sub(const Sub& from);

  inline Sub& operator=(const Sub& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sub(Sub&& from) noexcept
    : Sub() {
    *this = ::std::move(from);
  }

  inline Sub& operator=(Sub&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sub& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sub* internal_default_instance() {
    return reinterpret_cast<const Sub*>(
               &_Sub_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Sub* other);
  friend void swap(Sub& a, Sub& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sub* New() const final {
    return CreateMaybeMessage<Sub>(NULL);
  }

  Sub* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sub>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sub& from);
  void MergeFrom(const Sub& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sub* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destination = 1;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // string filter = 7;
  void clear_filter();
  static const int kFilterFieldNumber = 7;
  const ::std::string& filter() const;
  void set_filter(const ::std::string& value);
  #if LANG_CXX11
  void set_filter(::std::string&& value);
  #endif
  void set_filter(const char* value);
  void set_filter(const char* value, size_t size);
  ::std::string* mutable_filter();
  ::std::string* release_filter();
  void set_allocated_filter(::std::string* filter);

  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.Sub)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::internal::ArenaStringPtr filter_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Unsub : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.Unsub) */ {
 public:
  Unsub();
  virtual ~Unsub();

  Unsub(const Unsub& from);

  inline Unsub& operator=(const Unsub& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Unsub(Unsub&& from) noexcept
    : Unsub() {
    *this = ::std::move(from);
  }

  inline Unsub& operator=(Unsub&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Unsub& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Unsub* internal_default_instance() {
    return reinterpret_cast<const Unsub*>(
               &_Unsub_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Unsub* other);
  friend void swap(Unsub& a, Unsub& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Unsub* New() const final {
    return CreateMaybeMessage<Unsub>(NULL);
  }

  Unsub* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Unsub>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Unsub& from);
  void MergeFrom(const Unsub& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unsub* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destination = 1;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // string filter = 7;
  void clear_filter();
  static const int kFilterFieldNumber = 7;
  const ::std::string& filter() const;
  void set_filter(const ::std::string& value);
  #if LANG_CXX11
  void set_filter(::std::string&& value);
  #endif
  void set_filter(const char* value);
  void set_filter(const char* value, size_t size);
  ::std::string* mutable_filter();
  ::std::string* release_filter();
  void set_allocated_filter(::std::string* filter);

  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.Unsub)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::internal::ArenaStringPtr filter_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Get : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.Get) */ {
 public:
  Get();
  virtual ~Get();

  Get(const Get& from);

  inline Get& operator=(const Get& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Get(Get&& from) noexcept
    : Get() {
    *this = ::std::move(from);
  }

  inline Get& operator=(Get&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Get& default_instance();

  enum TimeoutPresentCase {
    kTimeout = 4,
    TIMEOUT_PRESENT_NOT_SET = 0,
  };

  enum UnitPresentCase {
    kUnit = 5,
    UNIT_PRESENT_NOT_SET = 0,
  };

  enum AutoAckPresentCase {
    kAutoAck = 6,
    AUTO_ACK_PRESENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Get* internal_default_instance() {
    return reinterpret_cast<const Get*>(
               &_Get_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Get* other);
  friend void swap(Get& a, Get& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Get* New() const final {
    return CreateMaybeMessage<Get>(NULL);
  }

  Get* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Get>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Get& from);
  void MergeFrom(const Get& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Get* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destination = 1;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // int32 fetch_size = 3;
  void clear_fetch_size();
  static const int kFetchSizeFieldNumber = 3;
  ::google::protobuf::int32 fetch_size() const;
  void set_fetch_size(::google::protobuf::int32 value);

  // int64 timeout = 4;
  private:
  bool has_timeout() const;
  public:
  void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  ::google::protobuf::int64 timeout() const;
  void set_timeout(::google::protobuf::int64 value);

  // int32 unit = 5;
  private:
  bool has_unit() const;
  public:
  void clear_unit();
  static const int kUnitFieldNumber = 5;
  ::google::protobuf::int32 unit() const;
  void set_unit(::google::protobuf::int32 value);

  // bool auto_ack = 6;
  private:
  bool has_auto_ack() const;
  public:
  void clear_auto_ack();
  static const int kAutoAckFieldNumber = 6;
  bool auto_ack() const;
  void set_auto_ack(bool value);

  void clear_timeout_present();
  TimeoutPresentCase timeout_present_case() const;
  void clear_unit_present();
  UnitPresentCase unit_present_case() const;
  void clear_auto_ack_present();
  AutoAckPresentCase auto_ack_present_case() const;
  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.Get)
 private:
  void set_has_timeout();
  void set_has_unit();
  void set_has_auto_ack();

  inline bool has_timeout_present() const;
  inline void clear_has_timeout_present();

  inline bool has_unit_present() const;
  inline void clear_has_unit_present();

  inline bool has_auto_ack_present() const;
  inline void clear_has_auto_ack_present();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::int32 fetch_size_;
  union TimeoutPresentUnion {
    TimeoutPresentUnion() {}
    ::google::protobuf::int64 timeout_;
  } timeout_present_;
  union UnitPresentUnion {
    UnitPresentUnion() {}
    ::google::protobuf::int32 unit_;
  } unit_present_;
  union AutoAckPresentUnion {
    AutoAckPresentUnion() {}
    bool auto_ack_;
  } auto_ack_present_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[3];

  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Messages : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.Messages) */ {
 public:
  Messages();
  virtual ~Messages();

  Messages(const Messages& from);

  inline Messages& operator=(const Messages& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Messages(Messages&& from) noexcept
    : Messages() {
    *this = ::std::move(from);
  }

  inline Messages& operator=(Messages&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Messages& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Messages* internal_default_instance() {
    return reinterpret_cast<const Messages*>(
               &_Messages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Messages* other);
  friend void swap(Messages& a, Messages& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Messages* New() const final {
    return CreateMaybeMessage<Messages>(NULL);
  }

  Messages* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Messages>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Messages& from);
  void MergeFrom(const Messages& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Messages* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes messages = 2;
  int messages_size() const;
  void clear_messages();
  static const int kMessagesFieldNumber = 2;
  const ::std::string& messages(int index) const;
  ::std::string* mutable_messages(int index);
  void set_messages(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_messages(int index, ::std::string&& value);
  #endif
  void set_messages(int index, const char* value);
  void set_messages(int index, const void* value, size_t size);
  ::std::string* add_messages();
  void add_messages(const ::std::string& value);
  #if LANG_CXX11
  void add_messages(::std::string&& value);
  #endif
  void add_messages(const char* value);
  void add_messages(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& messages() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_messages();

  // int64 batch_id = 1;
  void clear_batch_id();
  static const int kBatchIdFieldNumber = 1;
  ::google::protobuf::int64 batch_id() const;
  void set_batch_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.Messages)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> messages_;
  ::google::protobuf::int64 batch_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Dump : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.Dump) */ {
 public:
  Dump();
  virtual ~Dump();

  Dump(const Dump& from);

  inline Dump& operator=(const Dump& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Dump(Dump&& from) noexcept
    : Dump() {
    *this = ::std::move(from);
  }

  inline Dump& operator=(Dump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dump& default_instance();

  enum TimestampPresentCase {
    kTimestamp = 3,
    TIMESTAMP_PRESENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dump* internal_default_instance() {
    return reinterpret_cast<const Dump*>(
               &_Dump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Dump* other);
  friend void swap(Dump& a, Dump& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Dump* New() const final {
    return CreateMaybeMessage<Dump>(NULL);
  }

  Dump* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Dump>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Dump& from);
  void MergeFrom(const Dump& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dump* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string journal = 1;
  void clear_journal();
  static const int kJournalFieldNumber = 1;
  const ::std::string& journal() const;
  void set_journal(const ::std::string& value);
  #if LANG_CXX11
  void set_journal(::std::string&& value);
  #endif
  void set_journal(const char* value);
  void set_journal(const char* value, size_t size);
  ::std::string* mutable_journal();
  ::std::string* release_journal();
  void set_allocated_journal(::std::string* journal);

  // string gtid = 4;
  void clear_gtid();
  static const int kGtidFieldNumber = 4;
  const ::std::string& gtid() const;
  void set_gtid(const ::std::string& value);
  #if LANG_CXX11
  void set_gtid(::std::string&& value);
  #endif
  void set_gtid(const char* value);
  void set_gtid(const char* value, size_t size);
  ::std::string* mutable_gtid();
  ::std::string* release_gtid();
  void set_allocated_gtid(::std::string* gtid);

  // int64 position = 2;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  ::google::protobuf::int64 position() const;
  void set_position(::google::protobuf::int64 value);

  // int64 timestamp = 3;
  private:
  bool has_timestamp() const;
  public:
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  void clear_timestamp_present();
  TimestampPresentCase timestamp_present_case() const;
  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.Dump)
 private:
  void set_has_timestamp();

  inline bool has_timestamp_present() const;
  inline void clear_has_timestamp_present();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr journal_;
  ::google::protobuf::internal::ArenaStringPtr gtid_;
  ::google::protobuf::int64 position_;
  union TimestampPresentUnion {
    TimestampPresentUnion() {}
    ::google::protobuf::int64 timestamp_;
  } timestamp_present_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientRollback : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.woqutech.qdecoder.packages.ClientRollback) */ {
 public:
  ClientRollback();
  virtual ~ClientRollback();

  ClientRollback(const ClientRollback& from);

  inline ClientRollback& operator=(const ClientRollback& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientRollback(ClientRollback&& from) noexcept
    : ClientRollback() {
    *this = ::std::move(from);
  }

  inline ClientRollback& operator=(ClientRollback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRollback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientRollback* internal_default_instance() {
    return reinterpret_cast<const ClientRollback*>(
               &_ClientRollback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ClientRollback* other);
  friend void swap(ClientRollback& a, ClientRollback& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientRollback* New() const final {
    return CreateMaybeMessage<ClientRollback>(NULL);
  }

  ClientRollback* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientRollback>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientRollback& from);
  void MergeFrom(const ClientRollback& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientRollback* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destination = 1;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // int64 batch_id = 3;
  void clear_batch_id();
  static const int kBatchIdFieldNumber = 3;
  ::google::protobuf::int64 batch_id() const;
  void set_batch_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.woqutech.qdecoder.packages.ClientRollback)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::int64 batch_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_QDecoderProtocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Packet

// int32 magic_number = 1;
inline bool Packet::has_magic_number() const {
  return magic_number_present_case() == kMagicNumber;
}
inline void Packet::set_has_magic_number() {
  _oneof_case_[0] = kMagicNumber;
}
inline void Packet::clear_magic_number() {
  if (has_magic_number()) {
    magic_number_present_.magic_number_ = 0;
    clear_has_magic_number_present();
  }
}
inline ::google::protobuf::int32 Packet::magic_number() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Packet.magic_number)
  if (has_magic_number()) {
    return magic_number_present_.magic_number_;
  }
  return 0;
}
inline void Packet::set_magic_number(::google::protobuf::int32 value) {
  if (!has_magic_number()) {
    clear_magic_number_present();
    set_has_magic_number();
  }
  magic_number_present_.magic_number_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Packet.magic_number)
}

// int32 version = 2;
inline bool Packet::has_version() const {
  return version_present_case() == kVersion;
}
inline void Packet::set_has_version() {
  _oneof_case_[1] = kVersion;
}
inline void Packet::clear_version() {
  if (has_version()) {
    version_present_.version_ = 0;
    clear_has_version_present();
  }
}
inline ::google::protobuf::int32 Packet::version() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Packet.version)
  if (has_version()) {
    return version_present_.version_;
  }
  return 0;
}
inline void Packet::set_version(::google::protobuf::int32 value) {
  if (!has_version()) {
    clear_version_present();
    set_has_version();
  }
  version_present_.version_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Packet.version)
}

// .com.woqutech.qdecoder.packages.PacketType type = 3;
inline void Packet::clear_type() {
  type_ = 0;
}
inline ::com::woqutech::qdecoder::packages::PacketType Packet::type() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Packet.type)
  return static_cast< ::com::woqutech::qdecoder::packages::PacketType >(type_);
}
inline void Packet::set_type(::com::woqutech::qdecoder::packages::PacketType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Packet.type)
}

// .com.woqutech.qdecoder.packages.Compression compression = 4;
inline bool Packet::has_compression() const {
  return compression_present_case() == kCompression;
}
inline void Packet::set_has_compression() {
  _oneof_case_[2] = kCompression;
}
inline void Packet::clear_compression() {
  if (has_compression()) {
    compression_present_.compression_ = 0;
    clear_has_compression_present();
  }
}
inline ::com::woqutech::qdecoder::packages::Compression Packet::compression() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Packet.compression)
  if (has_compression()) {
    return static_cast< ::com::woqutech::qdecoder::packages::Compression >(compression_present_.compression_);
  }
  return static_cast< ::com::woqutech::qdecoder::packages::Compression >(0);
}
inline void Packet::set_compression(::com::woqutech::qdecoder::packages::Compression value) {
  if (!has_compression()) {
    clear_compression_present();
    set_has_compression();
  }
  compression_present_.compression_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Packet.compression)
}

// bytes body = 5;
inline void Packet::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Packet::body() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Packet.body)
  return body_.GetNoArena();
}
inline void Packet::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Packet.body)
}
#if LANG_CXX11
inline void Packet::set_body(::std::string&& value) {
  
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Packet.body)
}
#endif
inline void Packet::set_body(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Packet.body)
}
inline void Packet::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Packet.body)
}
inline ::std::string* Packet::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Packet.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Packet::release_body() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Packet.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Packet::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Packet.body)
}

inline bool Packet::has_magic_number_present() const {
  return magic_number_present_case() != MAGIC_NUMBER_PRESENT_NOT_SET;
}
inline void Packet::clear_has_magic_number_present() {
  _oneof_case_[0] = MAGIC_NUMBER_PRESENT_NOT_SET;
}
inline bool Packet::has_version_present() const {
  return version_present_case() != VERSION_PRESENT_NOT_SET;
}
inline void Packet::clear_has_version_present() {
  _oneof_case_[1] = VERSION_PRESENT_NOT_SET;
}
inline bool Packet::has_compression_present() const {
  return compression_present_case() != COMPRESSION_PRESENT_NOT_SET;
}
inline void Packet::clear_has_compression_present() {
  _oneof_case_[2] = COMPRESSION_PRESENT_NOT_SET;
}
inline Packet::MagicNumberPresentCase Packet::magic_number_present_case() const {
  return Packet::MagicNumberPresentCase(_oneof_case_[0]);
}
inline Packet::VersionPresentCase Packet::version_present_case() const {
  return Packet::VersionPresentCase(_oneof_case_[1]);
}
inline Packet::CompressionPresentCase Packet::compression_present_case() const {
  return Packet::CompressionPresentCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// HeartBeat

// int64 send_timestamp = 1;
inline void HeartBeat::clear_send_timestamp() {
  send_timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 HeartBeat::send_timestamp() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.HeartBeat.send_timestamp)
  return send_timestamp_;
}
inline void HeartBeat::set_send_timestamp(::google::protobuf::int64 value) {
  
  send_timestamp_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.HeartBeat.send_timestamp)
}

// int64 start_timestamp = 2;
inline void HeartBeat::clear_start_timestamp() {
  start_timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 HeartBeat::start_timestamp() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.HeartBeat.start_timestamp)
  return start_timestamp_;
}
inline void HeartBeat::set_start_timestamp(::google::protobuf::int64 value) {
  
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.HeartBeat.start_timestamp)
}

// -------------------------------------------------------------------

// Handshake

// string communication_encoding = 1;
inline bool Handshake::has_communication_encoding() const {
  return communication_encoding_present_case() == kCommunicationEncoding;
}
inline void Handshake::set_has_communication_encoding() {
  _oneof_case_[0] = kCommunicationEncoding;
}
inline void Handshake::clear_communication_encoding() {
  if (has_communication_encoding()) {
    communication_encoding_present_.communication_encoding_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_communication_encoding_present();
  }
}
inline const ::std::string& Handshake::communication_encoding() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Handshake.communication_encoding)
  if (has_communication_encoding()) {
    return communication_encoding_present_.communication_encoding_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Handshake::set_communication_encoding(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Handshake.communication_encoding)
  if (!has_communication_encoding()) {
    clear_communication_encoding_present();
    set_has_communication_encoding();
    communication_encoding_present_.communication_encoding_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  communication_encoding_present_.communication_encoding_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Handshake.communication_encoding)
}
#if LANG_CXX11
inline void Handshake::set_communication_encoding(::std::string&& value) {
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Handshake.communication_encoding)
  if (!has_communication_encoding()) {
    clear_communication_encoding_present();
    set_has_communication_encoding();
    communication_encoding_present_.communication_encoding_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  communication_encoding_present_.communication_encoding_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Handshake.communication_encoding)
}
#endif
inline void Handshake::set_communication_encoding(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_communication_encoding()) {
    clear_communication_encoding_present();
    set_has_communication_encoding();
    communication_encoding_present_.communication_encoding_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  communication_encoding_present_.communication_encoding_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Handshake.communication_encoding)
}
inline void Handshake::set_communication_encoding(const char* value, size_t size) {
  if (!has_communication_encoding()) {
    clear_communication_encoding_present();
    set_has_communication_encoding();
    communication_encoding_present_.communication_encoding_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  communication_encoding_present_.communication_encoding_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Handshake.communication_encoding)
}
inline ::std::string* Handshake::mutable_communication_encoding() {
  if (!has_communication_encoding()) {
    clear_communication_encoding_present();
    set_has_communication_encoding();
    communication_encoding_present_.communication_encoding_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Handshake.communication_encoding)
  return communication_encoding_present_.communication_encoding_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Handshake::release_communication_encoding() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Handshake.communication_encoding)
  if (has_communication_encoding()) {
    clear_has_communication_encoding_present();
    return communication_encoding_present_.communication_encoding_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Handshake::set_allocated_communication_encoding(::std::string* communication_encoding) {
  if (!has_communication_encoding()) {
    communication_encoding_present_.communication_encoding_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_communication_encoding_present();
  if (communication_encoding != NULL) {
    set_has_communication_encoding();
    communication_encoding_present_.communication_encoding_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), communication_encoding);
  }
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Handshake.communication_encoding)
}

// bytes seeds = 2;
inline void Handshake::clear_seeds() {
  seeds_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Handshake::seeds() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Handshake.seeds)
  return seeds_.GetNoArena();
}
inline void Handshake::set_seeds(const ::std::string& value) {
  
  seeds_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Handshake.seeds)
}
#if LANG_CXX11
inline void Handshake::set_seeds(::std::string&& value) {
  
  seeds_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Handshake.seeds)
}
#endif
inline void Handshake::set_seeds(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  seeds_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Handshake.seeds)
}
inline void Handshake::set_seeds(const void* value, size_t size) {
  
  seeds_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Handshake.seeds)
}
inline ::std::string* Handshake::mutable_seeds() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Handshake.seeds)
  return seeds_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Handshake::release_seeds() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Handshake.seeds)
  
  return seeds_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Handshake::set_allocated_seeds(::std::string* seeds) {
  if (seeds != NULL) {
    
  } else {
    
  }
  seeds_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seeds);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Handshake.seeds)
}

// .com.woqutech.qdecoder.packages.Compression supported_compressions = 3;
inline void Handshake::clear_supported_compressions() {
  supported_compressions_ = 0;
}
inline ::com::woqutech::qdecoder::packages::Compression Handshake::supported_compressions() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Handshake.supported_compressions)
  return static_cast< ::com::woqutech::qdecoder::packages::Compression >(supported_compressions_);
}
inline void Handshake::set_supported_compressions(::com::woqutech::qdecoder::packages::Compression value) {
  
  supported_compressions_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Handshake.supported_compressions)
}

inline bool Handshake::has_communication_encoding_present() const {
  return communication_encoding_present_case() != COMMUNICATION_ENCODING_PRESENT_NOT_SET;
}
inline void Handshake::clear_has_communication_encoding_present() {
  _oneof_case_[0] = COMMUNICATION_ENCODING_PRESENT_NOT_SET;
}
inline Handshake::CommunicationEncodingPresentCase Handshake::communication_encoding_present_case() const {
  return Handshake::CommunicationEncodingPresentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientAuth

// string username = 1;
inline void ClientAuth::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientAuth::username() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAuth.username)
  return username_.GetNoArena();
}
inline void ClientAuth::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAuth.username)
}
#if LANG_CXX11
inline void ClientAuth::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.ClientAuth.username)
}
#endif
inline void ClientAuth::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.ClientAuth.username)
}
inline void ClientAuth::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.ClientAuth.username)
}
inline ::std::string* ClientAuth::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.ClientAuth.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientAuth::release_username() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.ClientAuth.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientAuth::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.ClientAuth.username)
}

// bytes password = 2;
inline void ClientAuth::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientAuth::password() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAuth.password)
  return password_.GetNoArena();
}
inline void ClientAuth::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAuth.password)
}
#if LANG_CXX11
inline void ClientAuth::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.ClientAuth.password)
}
#endif
inline void ClientAuth::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.ClientAuth.password)
}
inline void ClientAuth::set_password(const void* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.ClientAuth.password)
}
inline ::std::string* ClientAuth::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.ClientAuth.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientAuth::release_password() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.ClientAuth.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientAuth::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.ClientAuth.password)
}

// int32 net_read_timeout = 3;
inline bool ClientAuth::has_net_read_timeout() const {
  return net_read_timeout_present_case() == kNetReadTimeout;
}
inline void ClientAuth::set_has_net_read_timeout() {
  _oneof_case_[0] = kNetReadTimeout;
}
inline void ClientAuth::clear_net_read_timeout() {
  if (has_net_read_timeout()) {
    net_read_timeout_present_.net_read_timeout_ = 0;
    clear_has_net_read_timeout_present();
  }
}
inline ::google::protobuf::int32 ClientAuth::net_read_timeout() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAuth.net_read_timeout)
  if (has_net_read_timeout()) {
    return net_read_timeout_present_.net_read_timeout_;
  }
  return 0;
}
inline void ClientAuth::set_net_read_timeout(::google::protobuf::int32 value) {
  if (!has_net_read_timeout()) {
    clear_net_read_timeout_present();
    set_has_net_read_timeout();
  }
  net_read_timeout_present_.net_read_timeout_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAuth.net_read_timeout)
}

// int32 net_write_timeout = 4;
inline bool ClientAuth::has_net_write_timeout() const {
  return net_write_timeout_present_case() == kNetWriteTimeout;
}
inline void ClientAuth::set_has_net_write_timeout() {
  _oneof_case_[1] = kNetWriteTimeout;
}
inline void ClientAuth::clear_net_write_timeout() {
  if (has_net_write_timeout()) {
    net_write_timeout_present_.net_write_timeout_ = 0;
    clear_has_net_write_timeout_present();
  }
}
inline ::google::protobuf::int32 ClientAuth::net_write_timeout() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAuth.net_write_timeout)
  if (has_net_write_timeout()) {
    return net_write_timeout_present_.net_write_timeout_;
  }
  return 0;
}
inline void ClientAuth::set_net_write_timeout(::google::protobuf::int32 value) {
  if (!has_net_write_timeout()) {
    clear_net_write_timeout_present();
    set_has_net_write_timeout();
  }
  net_write_timeout_present_.net_write_timeout_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAuth.net_write_timeout)
}

// string destination = 5;
inline void ClientAuth::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientAuth::destination() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAuth.destination)
  return destination_.GetNoArena();
}
inline void ClientAuth::set_destination(const ::std::string& value) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAuth.destination)
}
#if LANG_CXX11
inline void ClientAuth::set_destination(::std::string&& value) {
  
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.ClientAuth.destination)
}
#endif
inline void ClientAuth::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.ClientAuth.destination)
}
inline void ClientAuth::set_destination(const char* value, size_t size) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.ClientAuth.destination)
}
inline ::std::string* ClientAuth::mutable_destination() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.ClientAuth.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientAuth::release_destination() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.ClientAuth.destination)
  
  return destination_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientAuth::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    
  } else {
    
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.ClientAuth.destination)
}

// string client_id = 6;
inline void ClientAuth::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientAuth::client_id() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAuth.client_id)
  return client_id_.GetNoArena();
}
inline void ClientAuth::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAuth.client_id)
}
#if LANG_CXX11
inline void ClientAuth::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.ClientAuth.client_id)
}
#endif
inline void ClientAuth::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.ClientAuth.client_id)
}
inline void ClientAuth::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.ClientAuth.client_id)
}
inline ::std::string* ClientAuth::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.ClientAuth.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientAuth::release_client_id() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.ClientAuth.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientAuth::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.ClientAuth.client_id)
}

// string filter = 7;
inline void ClientAuth::clear_filter() {
  filter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientAuth::filter() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAuth.filter)
  return filter_.GetNoArena();
}
inline void ClientAuth::set_filter(const ::std::string& value) {
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAuth.filter)
}
#if LANG_CXX11
inline void ClientAuth::set_filter(::std::string&& value) {
  
  filter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.ClientAuth.filter)
}
#endif
inline void ClientAuth::set_filter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.ClientAuth.filter)
}
inline void ClientAuth::set_filter(const char* value, size_t size) {
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.ClientAuth.filter)
}
inline ::std::string* ClientAuth::mutable_filter() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.ClientAuth.filter)
  return filter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientAuth::release_filter() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.ClientAuth.filter)
  
  return filter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientAuth::set_allocated_filter(::std::string* filter) {
  if (filter != NULL) {
    
  } else {
    
  }
  filter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filter);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.ClientAuth.filter)
}

// int64 start_timestamp = 8;
inline void ClientAuth::clear_start_timestamp() {
  start_timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ClientAuth::start_timestamp() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAuth.start_timestamp)
  return start_timestamp_;
}
inline void ClientAuth::set_start_timestamp(::google::protobuf::int64 value) {
  
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAuth.start_timestamp)
}

inline bool ClientAuth::has_net_read_timeout_present() const {
  return net_read_timeout_present_case() != NET_READ_TIMEOUT_PRESENT_NOT_SET;
}
inline void ClientAuth::clear_has_net_read_timeout_present() {
  _oneof_case_[0] = NET_READ_TIMEOUT_PRESENT_NOT_SET;
}
inline bool ClientAuth::has_net_write_timeout_present() const {
  return net_write_timeout_present_case() != NET_WRITE_TIMEOUT_PRESENT_NOT_SET;
}
inline void ClientAuth::clear_has_net_write_timeout_present() {
  _oneof_case_[1] = NET_WRITE_TIMEOUT_PRESENT_NOT_SET;
}
inline ClientAuth::NetReadTimeoutPresentCase ClientAuth::net_read_timeout_present_case() const {
  return ClientAuth::NetReadTimeoutPresentCase(_oneof_case_[0]);
}
inline ClientAuth::NetWriteTimeoutPresentCase ClientAuth::net_write_timeout_present_case() const {
  return ClientAuth::NetWriteTimeoutPresentCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// Ack

// int32 error_code = 1;
inline bool Ack::has_error_code() const {
  return error_code_present_case() == kErrorCode;
}
inline void Ack::set_has_error_code() {
  _oneof_case_[0] = kErrorCode;
}
inline void Ack::clear_error_code() {
  if (has_error_code()) {
    error_code_present_.error_code_ = 0;
    clear_has_error_code_present();
  }
}
inline ::google::protobuf::int32 Ack::error_code() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Ack.error_code)
  if (has_error_code()) {
    return error_code_present_.error_code_;
  }
  return 0;
}
inline void Ack::set_error_code(::google::protobuf::int32 value) {
  if (!has_error_code()) {
    clear_error_code_present();
    set_has_error_code();
  }
  error_code_present_.error_code_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Ack.error_code)
}

// string error_message = 2;
inline void Ack::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Ack::error_message() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Ack.error_message)
  return error_message_.GetNoArena();
}
inline void Ack::set_error_message(const ::std::string& value) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Ack.error_message)
}
#if LANG_CXX11
inline void Ack::set_error_message(::std::string&& value) {
  
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Ack.error_message)
}
#endif
inline void Ack::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Ack.error_message)
}
inline void Ack::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Ack.error_message)
}
inline ::std::string* Ack::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Ack.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ack::release_error_message() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Ack.error_message)
  
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ack::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Ack.error_message)
}

inline bool Ack::has_error_code_present() const {
  return error_code_present_case() != ERROR_CODE_PRESENT_NOT_SET;
}
inline void Ack::clear_has_error_code_present() {
  _oneof_case_[0] = ERROR_CODE_PRESENT_NOT_SET;
}
inline Ack::ErrorCodePresentCase Ack::error_code_present_case() const {
  return Ack::ErrorCodePresentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientAck

// string destination = 1;
inline void ClientAck::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientAck::destination() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAck.destination)
  return destination_.GetNoArena();
}
inline void ClientAck::set_destination(const ::std::string& value) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAck.destination)
}
#if LANG_CXX11
inline void ClientAck::set_destination(::std::string&& value) {
  
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.ClientAck.destination)
}
#endif
inline void ClientAck::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.ClientAck.destination)
}
inline void ClientAck::set_destination(const char* value, size_t size) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.ClientAck.destination)
}
inline ::std::string* ClientAck::mutable_destination() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.ClientAck.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientAck::release_destination() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.ClientAck.destination)
  
  return destination_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientAck::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    
  } else {
    
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.ClientAck.destination)
}

// string client_id = 2;
inline void ClientAck::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientAck::client_id() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAck.client_id)
  return client_id_.GetNoArena();
}
inline void ClientAck::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAck.client_id)
}
#if LANG_CXX11
inline void ClientAck::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.ClientAck.client_id)
}
#endif
inline void ClientAck::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.ClientAck.client_id)
}
inline void ClientAck::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.ClientAck.client_id)
}
inline ::std::string* ClientAck::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.ClientAck.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientAck::release_client_id() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.ClientAck.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientAck::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.ClientAck.client_id)
}

// int64 batch_id = 3;
inline void ClientAck::clear_batch_id() {
  batch_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ClientAck::batch_id() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientAck.batch_id)
  return batch_id_;
}
inline void ClientAck::set_batch_id(::google::protobuf::int64 value) {
  
  batch_id_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientAck.batch_id)
}

// -------------------------------------------------------------------

// Sub

// string destination = 1;
inline void Sub::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sub::destination() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Sub.destination)
  return destination_.GetNoArena();
}
inline void Sub::set_destination(const ::std::string& value) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Sub.destination)
}
#if LANG_CXX11
inline void Sub::set_destination(::std::string&& value) {
  
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Sub.destination)
}
#endif
inline void Sub::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Sub.destination)
}
inline void Sub::set_destination(const char* value, size_t size) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Sub.destination)
}
inline ::std::string* Sub::mutable_destination() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Sub.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sub::release_destination() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Sub.destination)
  
  return destination_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sub::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    
  } else {
    
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Sub.destination)
}

// string client_id = 2;
inline void Sub::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sub::client_id() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Sub.client_id)
  return client_id_.GetNoArena();
}
inline void Sub::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Sub.client_id)
}
#if LANG_CXX11
inline void Sub::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Sub.client_id)
}
#endif
inline void Sub::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Sub.client_id)
}
inline void Sub::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Sub.client_id)
}
inline ::std::string* Sub::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Sub.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sub::release_client_id() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Sub.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sub::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Sub.client_id)
}

// string filter = 7;
inline void Sub::clear_filter() {
  filter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sub::filter() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Sub.filter)
  return filter_.GetNoArena();
}
inline void Sub::set_filter(const ::std::string& value) {
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Sub.filter)
}
#if LANG_CXX11
inline void Sub::set_filter(::std::string&& value) {
  
  filter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Sub.filter)
}
#endif
inline void Sub::set_filter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Sub.filter)
}
inline void Sub::set_filter(const char* value, size_t size) {
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Sub.filter)
}
inline ::std::string* Sub::mutable_filter() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Sub.filter)
  return filter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sub::release_filter() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Sub.filter)
  
  return filter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sub::set_allocated_filter(::std::string* filter) {
  if (filter != NULL) {
    
  } else {
    
  }
  filter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filter);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Sub.filter)
}

// -------------------------------------------------------------------

// Unsub

// string destination = 1;
inline void Unsub::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Unsub::destination() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Unsub.destination)
  return destination_.GetNoArena();
}
inline void Unsub::set_destination(const ::std::string& value) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Unsub.destination)
}
#if LANG_CXX11
inline void Unsub::set_destination(::std::string&& value) {
  
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Unsub.destination)
}
#endif
inline void Unsub::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Unsub.destination)
}
inline void Unsub::set_destination(const char* value, size_t size) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Unsub.destination)
}
inline ::std::string* Unsub::mutable_destination() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Unsub.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Unsub::release_destination() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Unsub.destination)
  
  return destination_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Unsub::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    
  } else {
    
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Unsub.destination)
}

// string client_id = 2;
inline void Unsub::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Unsub::client_id() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Unsub.client_id)
  return client_id_.GetNoArena();
}
inline void Unsub::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Unsub.client_id)
}
#if LANG_CXX11
inline void Unsub::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Unsub.client_id)
}
#endif
inline void Unsub::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Unsub.client_id)
}
inline void Unsub::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Unsub.client_id)
}
inline ::std::string* Unsub::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Unsub.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Unsub::release_client_id() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Unsub.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Unsub::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Unsub.client_id)
}

// string filter = 7;
inline void Unsub::clear_filter() {
  filter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Unsub::filter() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Unsub.filter)
  return filter_.GetNoArena();
}
inline void Unsub::set_filter(const ::std::string& value) {
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Unsub.filter)
}
#if LANG_CXX11
inline void Unsub::set_filter(::std::string&& value) {
  
  filter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Unsub.filter)
}
#endif
inline void Unsub::set_filter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Unsub.filter)
}
inline void Unsub::set_filter(const char* value, size_t size) {
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Unsub.filter)
}
inline ::std::string* Unsub::mutable_filter() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Unsub.filter)
  return filter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Unsub::release_filter() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Unsub.filter)
  
  return filter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Unsub::set_allocated_filter(::std::string* filter) {
  if (filter != NULL) {
    
  } else {
    
  }
  filter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filter);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Unsub.filter)
}

// -------------------------------------------------------------------

// Get

// string destination = 1;
inline void Get::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Get::destination() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Get.destination)
  return destination_.GetNoArena();
}
inline void Get::set_destination(const ::std::string& value) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Get.destination)
}
#if LANG_CXX11
inline void Get::set_destination(::std::string&& value) {
  
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Get.destination)
}
#endif
inline void Get::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Get.destination)
}
inline void Get::set_destination(const char* value, size_t size) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Get.destination)
}
inline ::std::string* Get::mutable_destination() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Get.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Get::release_destination() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Get.destination)
  
  return destination_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Get::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    
  } else {
    
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Get.destination)
}

// string client_id = 2;
inline void Get::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Get::client_id() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Get.client_id)
  return client_id_.GetNoArena();
}
inline void Get::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Get.client_id)
}
#if LANG_CXX11
inline void Get::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Get.client_id)
}
#endif
inline void Get::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Get.client_id)
}
inline void Get::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Get.client_id)
}
inline ::std::string* Get::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Get.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Get::release_client_id() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Get.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Get::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Get.client_id)
}

// int32 fetch_size = 3;
inline void Get::clear_fetch_size() {
  fetch_size_ = 0;
}
inline ::google::protobuf::int32 Get::fetch_size() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Get.fetch_size)
  return fetch_size_;
}
inline void Get::set_fetch_size(::google::protobuf::int32 value) {
  
  fetch_size_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Get.fetch_size)
}

// int64 timeout = 4;
inline bool Get::has_timeout() const {
  return timeout_present_case() == kTimeout;
}
inline void Get::set_has_timeout() {
  _oneof_case_[0] = kTimeout;
}
inline void Get::clear_timeout() {
  if (has_timeout()) {
    timeout_present_.timeout_ = GOOGLE_LONGLONG(0);
    clear_has_timeout_present();
  }
}
inline ::google::protobuf::int64 Get::timeout() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Get.timeout)
  if (has_timeout()) {
    return timeout_present_.timeout_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Get::set_timeout(::google::protobuf::int64 value) {
  if (!has_timeout()) {
    clear_timeout_present();
    set_has_timeout();
  }
  timeout_present_.timeout_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Get.timeout)
}

// int32 unit = 5;
inline bool Get::has_unit() const {
  return unit_present_case() == kUnit;
}
inline void Get::set_has_unit() {
  _oneof_case_[1] = kUnit;
}
inline void Get::clear_unit() {
  if (has_unit()) {
    unit_present_.unit_ = 0;
    clear_has_unit_present();
  }
}
inline ::google::protobuf::int32 Get::unit() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Get.unit)
  if (has_unit()) {
    return unit_present_.unit_;
  }
  return 0;
}
inline void Get::set_unit(::google::protobuf::int32 value) {
  if (!has_unit()) {
    clear_unit_present();
    set_has_unit();
  }
  unit_present_.unit_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Get.unit)
}

// bool auto_ack = 6;
inline bool Get::has_auto_ack() const {
  return auto_ack_present_case() == kAutoAck;
}
inline void Get::set_has_auto_ack() {
  _oneof_case_[2] = kAutoAck;
}
inline void Get::clear_auto_ack() {
  if (has_auto_ack()) {
    auto_ack_present_.auto_ack_ = false;
    clear_has_auto_ack_present();
  }
}
inline bool Get::auto_ack() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Get.auto_ack)
  if (has_auto_ack()) {
    return auto_ack_present_.auto_ack_;
  }
  return false;
}
inline void Get::set_auto_ack(bool value) {
  if (!has_auto_ack()) {
    clear_auto_ack_present();
    set_has_auto_ack();
  }
  auto_ack_present_.auto_ack_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Get.auto_ack)
}

inline bool Get::has_timeout_present() const {
  return timeout_present_case() != TIMEOUT_PRESENT_NOT_SET;
}
inline void Get::clear_has_timeout_present() {
  _oneof_case_[0] = TIMEOUT_PRESENT_NOT_SET;
}
inline bool Get::has_unit_present() const {
  return unit_present_case() != UNIT_PRESENT_NOT_SET;
}
inline void Get::clear_has_unit_present() {
  _oneof_case_[1] = UNIT_PRESENT_NOT_SET;
}
inline bool Get::has_auto_ack_present() const {
  return auto_ack_present_case() != AUTO_ACK_PRESENT_NOT_SET;
}
inline void Get::clear_has_auto_ack_present() {
  _oneof_case_[2] = AUTO_ACK_PRESENT_NOT_SET;
}
inline Get::TimeoutPresentCase Get::timeout_present_case() const {
  return Get::TimeoutPresentCase(_oneof_case_[0]);
}
inline Get::UnitPresentCase Get::unit_present_case() const {
  return Get::UnitPresentCase(_oneof_case_[1]);
}
inline Get::AutoAckPresentCase Get::auto_ack_present_case() const {
  return Get::AutoAckPresentCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// Messages

// int64 batch_id = 1;
inline void Messages::clear_batch_id() {
  batch_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Messages::batch_id() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Messages.batch_id)
  return batch_id_;
}
inline void Messages::set_batch_id(::google::protobuf::int64 value) {
  
  batch_id_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Messages.batch_id)
}

// repeated bytes messages = 2;
inline int Messages::messages_size() const {
  return messages_.size();
}
inline void Messages::clear_messages() {
  messages_.Clear();
}
inline const ::std::string& Messages::messages(int index) const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Messages.messages)
  return messages_.Get(index);
}
inline ::std::string* Messages::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Messages.messages)
  return messages_.Mutable(index);
}
inline void Messages::set_messages(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Messages.messages)
  messages_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Messages::set_messages(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Messages.messages)
  messages_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Messages::set_messages(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  messages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Messages.messages)
}
inline void Messages::set_messages(int index, const void* value, size_t size) {
  messages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Messages.messages)
}
inline ::std::string* Messages::add_messages() {
  // @@protoc_insertion_point(field_add_mutable:com.woqutech.qdecoder.packages.Messages.messages)
  return messages_.Add();
}
inline void Messages::add_messages(const ::std::string& value) {
  messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.woqutech.qdecoder.packages.Messages.messages)
}
#if LANG_CXX11
inline void Messages::add_messages(::std::string&& value) {
  messages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.woqutech.qdecoder.packages.Messages.messages)
}
#endif
inline void Messages::add_messages(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.woqutech.qdecoder.packages.Messages.messages)
}
inline void Messages::add_messages(const void* value, size_t size) {
  messages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.woqutech.qdecoder.packages.Messages.messages)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Messages::messages() const {
  // @@protoc_insertion_point(field_list:com.woqutech.qdecoder.packages.Messages.messages)
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Messages::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:com.woqutech.qdecoder.packages.Messages.messages)
  return &messages_;
}

// -------------------------------------------------------------------

// Dump

// string journal = 1;
inline void Dump::clear_journal() {
  journal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Dump::journal() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Dump.journal)
  return journal_.GetNoArena();
}
inline void Dump::set_journal(const ::std::string& value) {
  
  journal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Dump.journal)
}
#if LANG_CXX11
inline void Dump::set_journal(::std::string&& value) {
  
  journal_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Dump.journal)
}
#endif
inline void Dump::set_journal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  journal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Dump.journal)
}
inline void Dump::set_journal(const char* value, size_t size) {
  
  journal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Dump.journal)
}
inline ::std::string* Dump::mutable_journal() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Dump.journal)
  return journal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Dump::release_journal() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Dump.journal)
  
  return journal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Dump::set_allocated_journal(::std::string* journal) {
  if (journal != NULL) {
    
  } else {
    
  }
  journal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), journal);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Dump.journal)
}

// int64 position = 2;
inline void Dump::clear_position() {
  position_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Dump::position() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Dump.position)
  return position_;
}
inline void Dump::set_position(::google::protobuf::int64 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Dump.position)
}

// int64 timestamp = 3;
inline bool Dump::has_timestamp() const {
  return timestamp_present_case() == kTimestamp;
}
inline void Dump::set_has_timestamp() {
  _oneof_case_[0] = kTimestamp;
}
inline void Dump::clear_timestamp() {
  if (has_timestamp()) {
    timestamp_present_.timestamp_ = GOOGLE_LONGLONG(0);
    clear_has_timestamp_present();
  }
}
inline ::google::protobuf::int64 Dump::timestamp() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Dump.timestamp)
  if (has_timestamp()) {
    return timestamp_present_.timestamp_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Dump::set_timestamp(::google::protobuf::int64 value) {
  if (!has_timestamp()) {
    clear_timestamp_present();
    set_has_timestamp();
  }
  timestamp_present_.timestamp_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Dump.timestamp)
}

// string gtid = 4;
inline void Dump::clear_gtid() {
  gtid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Dump::gtid() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.Dump.gtid)
  return gtid_.GetNoArena();
}
inline void Dump::set_gtid(const ::std::string& value) {
  
  gtid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.Dump.gtid)
}
#if LANG_CXX11
inline void Dump::set_gtid(::std::string&& value) {
  
  gtid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.Dump.gtid)
}
#endif
inline void Dump::set_gtid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gtid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.Dump.gtid)
}
inline void Dump::set_gtid(const char* value, size_t size) {
  
  gtid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.Dump.gtid)
}
inline ::std::string* Dump::mutable_gtid() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.Dump.gtid)
  return gtid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Dump::release_gtid() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.Dump.gtid)
  
  return gtid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Dump::set_allocated_gtid(::std::string* gtid) {
  if (gtid != NULL) {
    
  } else {
    
  }
  gtid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gtid);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.Dump.gtid)
}

inline bool Dump::has_timestamp_present() const {
  return timestamp_present_case() != TIMESTAMP_PRESENT_NOT_SET;
}
inline void Dump::clear_has_timestamp_present() {
  _oneof_case_[0] = TIMESTAMP_PRESENT_NOT_SET;
}
inline Dump::TimestampPresentCase Dump::timestamp_present_case() const {
  return Dump::TimestampPresentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientRollback

// string destination = 1;
inline void ClientRollback::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientRollback::destination() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientRollback.destination)
  return destination_.GetNoArena();
}
inline void ClientRollback::set_destination(const ::std::string& value) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientRollback.destination)
}
#if LANG_CXX11
inline void ClientRollback::set_destination(::std::string&& value) {
  
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.ClientRollback.destination)
}
#endif
inline void ClientRollback::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.ClientRollback.destination)
}
inline void ClientRollback::set_destination(const char* value, size_t size) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.ClientRollback.destination)
}
inline ::std::string* ClientRollback::mutable_destination() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.ClientRollback.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientRollback::release_destination() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.ClientRollback.destination)
  
  return destination_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientRollback::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    
  } else {
    
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.ClientRollback.destination)
}

// string client_id = 2;
inline void ClientRollback::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientRollback::client_id() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientRollback.client_id)
  return client_id_.GetNoArena();
}
inline void ClientRollback::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientRollback.client_id)
}
#if LANG_CXX11
inline void ClientRollback::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.woqutech.qdecoder.packages.ClientRollback.client_id)
}
#endif
inline void ClientRollback::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.woqutech.qdecoder.packages.ClientRollback.client_id)
}
inline void ClientRollback::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.woqutech.qdecoder.packages.ClientRollback.client_id)
}
inline ::std::string* ClientRollback::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:com.woqutech.qdecoder.packages.ClientRollback.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientRollback::release_client_id() {
  // @@protoc_insertion_point(field_release:com.woqutech.qdecoder.packages.ClientRollback.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientRollback::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:com.woqutech.qdecoder.packages.ClientRollback.client_id)
}

// int64 batch_id = 3;
inline void ClientRollback::clear_batch_id() {
  batch_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ClientRollback::batch_id() const {
  // @@protoc_insertion_point(field_get:com.woqutech.qdecoder.packages.ClientRollback.batch_id)
  return batch_id_;
}
inline void ClientRollback::set_batch_id(::google::protobuf::int64 value) {
  
  batch_id_ = value;
  // @@protoc_insertion_point(field_set:com.woqutech.qdecoder.packages.ClientRollback.batch_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace packages
}  // namespace qdecoder
}  // namespace woqutech
}  // namespace com

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::woqutech::qdecoder::packages::Compression> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::woqutech::qdecoder::packages::Compression>() {
  return ::com::woqutech::qdecoder::packages::Compression_descriptor();
}
template <> struct is_proto_enum< ::com::woqutech::qdecoder::packages::PacketType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::woqutech::qdecoder::packages::PacketType>() {
  return ::com::woqutech::qdecoder::packages::PacketType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_QDecoderProtocol_2eproto
